<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Ruby Journal]]></title>
  <link href="http://ruby-journal.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://ruby-journal.com/"/>
  <updated>2013-10-30T17:52:46+11:00</updated>
  <id>http://ruby-journal.com/</id>
  <author>
    <name><![CDATA[Trung Lê]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to import millions records via ActiveRecord within minutes not hours]]></title>
    <link href="http://ruby-journal.com/rails/activerecord/unix/bash/how-to-import-millions-records-via-activerecord-within-minutes-not-hours/"/>
    <updated>2013-10-30T17:23:00+11:00</updated>
    <id>http://ruby-journal.com/rails/activerecord/unix/bash/how-to-import-millions-records-via-activerecord-within-minutes-not-hours</id>
    <content type="html"><![CDATA[<p>{{ post.title }}</p>

<p>In today tutorial, I’ll show you how to optimise a ActiveRecord import script by 300%. My solution is better than other solution as it doesn’t use any SQL hack, thus you can retain the integrity with the data by running it through ActiveRecord normally.</p>

<!--more-->

<p>At work, I am assigned a task to import millions rows of records from a 300MB CSV file into Rails app. The rake task takes in FILE and process it with ActiveRecord.</p>

<p><code>
FILE=/tmp/big_file.csv rake data:import
</code></p>

<p>And soon I bumped into performance issue because ActiveRecord could not release garbage effectively. The script tooks <em>~2hrs</em> to complete. This is unacceptable to my standard.</p>

<p>There are various workarounds on the net such as using <code>ar_import</code> gem which uses SQL INSERT. However I do not like these SQL solutions as there are so many callbacks with my models and data integrity is very important. So I come up with an alternative solution:</p>

<ul>
  <li>Split the big_file.csv into smaller files</li>
  <li>Loop through these smaller chunks and recursively run rake task on each</li>
</ul>

<p>So now you wonder how the above solution works better. It is because now we run many small processes in which Rails won’t have to deal much with big GC. Once a process is completed, memory will be instantly released. Now, let’s code this up using shell script, I chose bash as example (please adapt to fit your purpose):</p>

<p>```bash
#! /bin/bash</p>

<p>NUMBER_OF_SPLIT_LINES=50000
SPLIT_FILE_PREFIX=’small_’
BIG_FILE_PATH=/tmp/big_file.csv
SPLIT_FILES=/tmp/$SPLIT_FILE_PREFIX*</p>

<p>temp_home () {
  cd /tmp
}</p>

<p>rails_app_home () {
  cd /your_app
}</p>

<p>split_big_csv_into_small_chunks () {
  echo “Split $BIG_FILE_PATH file into small chunks with size $NUMBER_OF_SPLIT_LINES lines…”
  temp_home &amp;&amp; split -l $NUMBER_OF_SPLIT_LINES $BIG_FILE_PATH $SPLIT_FILE_PREFIX
}</p>

<p>process_split_files () {
  for f in $SPLIT_FILES
  do
    echo “Processing $f file…”
    rails_app_home &amp;&amp; FILE=$f rake data:import
  done
}</p>

<p>split_big_csv_into_small_chunks
process_split_files
```</p>

<p>Let’s go through the above script. I use <code>split</code> UNIX command to split the big file into many smaller files, each with 50000 lines. Then I loop through these small files and parse it to rake task to run.</p>

<p>Now, how many minutes you think our bash script would take to finish? It is <em>3 mintutes</em> - no kidding! This is a massive gain compared to 2hrs.</p>

<p>Ruby/Rails are not the best for dealing with huge chunk of memory. So before deciding to try some SQL way, you can be pragmatic and abuse UNIX by spawning as many processes as your computer can handle and you’ll be surprised on how much gain you would achieve. Good luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exposing ActiveRecord model attributes to Liquid dynamically]]></title>
    <link href="http://ruby-journal.com/rails/exposing-activerecord-model-attributes-to-liquid-dynamically/"/>
    <updated>2012-03-12T12:52:00+11:00</updated>
    <id>http://ruby-journal.com/rails/exposing-activerecord-model-attributes-to-liquid-dynamically</id>
    <content type="html"><![CDATA[<p>{{ post.title }}</p>

<p><a href="http://liquidmarkup.org/">Liquid</a> is a powerful templating tool especially when
used with rails. It is quite common that you have to expose ActiveRecord attributes
to liquid. You can achieve that by implement <code>to_liquid</code> method in your ActiveRecord
model so it acts as if it were <code>Liquid::Drop</code>, OR you can use the helper <code>liquid_methods</code>
to tell which attributes / call-able methods of the instance that could be passed
with the <code>liquid_methods</code> call. In most of cases, people tend to use the latter method
because they could narrow the exposure scope to liquid.</p>

<p>However, what if your model has so many attributes and typing all them out for
the <code>liquid_methods</code> seems arduous, you can dynamically mapping attributes by
creating a module:</p>

<p>{% codeblock lib/attributes_to_liquid_methods_mapper.rb lang:ruby %}
module AttributesToLiquidMethodsMapper
  def self.included(base)
    base.class_eval do
      base.attribute_names.each do |attribute|
        liquid_methods attribute.to_sym
      end
    end
  end
end
{% endcodeblock %}</p>

<p>And you also need to include the above module in the ActiveRecord classes that
you want to be exposed to Liquid:</p>

<p><code>ruby
class MyObject &lt; ActiveRecord::Base
  require 'attributes_to_liquid_methods_mapper'
  include AttributesToLiquidMethodsMapper
end
</code></p>

<p>Hope you enjoy this tutorial. Comments and feedbacks are greatly welcomed :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Define Fixtures with Polymorphic Association]]></title>
    <link href="http://ruby-journal.com/rails/define-fixtures-with-polymorphic-association/"/>
    <updated>2012-03-09T15:16:00+11:00</updated>
    <id>http://ruby-journal.com/rails/define-fixtures-with-polymorphic-association</id>
    <content type="html"><![CDATA[<p>{{ post.title }}</p>

<p>It is more than often that you have to write a fixtures for models with polymorphic
association. In this short tutorial, I will show you how to use few shortcut trick
to create fixtures.</p>

<p>Assume we have following code:</p>

<p>```ruby
class Car &lt; ActiveRecord::Base
  belongs_to :borrowable, :polymorphic =&gt; true
end</p>

<p>class Company &lt; ActiveRecord::Base
  has_many :cars, :as =&gt; :borrowable
end</p>

<p>```</p>

<p>Above is just a very simple code declaring a polymorphic association between
Company to Car. Next, we will write some fixtures for the sake
of testing.</p>

<p>```
# Company fixtures
google:
  id: 1
  name: Google</p>

<h1 id="car-fixtures">car fixtures</h1>
<p>ferrari:
  name: F430
  borrowable_id: 1
  borrowable_type: Company
```</p>

<p>We could do better by referencing to Company fixture via named fixture, so
the above car fixture would be:</p>

<p><code>
ferrari:
  name: F430
  borrowable: google (Company)
</code></p>

<p>Please be noted that the syntax of line <code>borrowable</code> now has an additonal <code>(Company)</code>
keyword. This is to tell rails that the <code>borrowable_type</code> is of <code>Company</code> class.
Without that, the fixtures will set <code>borrowable_type</code> to <code>nil</code>, thus invalid.</p>

<p>Hope you find this tutorial useful. And please avoid using fixures as much as you can. Use factory_girl or machinist. See you in the next tutorial.</p>
]]></content>
  </entry>
  
</feed>
